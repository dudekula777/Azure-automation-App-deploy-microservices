name: End-to-End CI/CD Pipeline

on:
  workflow_dispatch: # Manual trigger
  push:
    branches: [ main ]

env:
  # Azure Service Principal Credentials
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  
  # Environment Configuration
  ENVIRONMENT: dev
  NAMESPACE: healthcare-dev
  TF_WORKING_DIR: infrastructure/environments/dev

jobs:
  # ============================================================
  # STAGE 1: Terraform Infrastructure Provisioning
  # ============================================================
  terraform-infrastructure:
    name: 1 - Terraform Infrastructure
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      aks-cluster-name: ${{ steps.outputs.outputs.cluster-name }}
      aks-resource-group: ${{ steps.outputs.outputs.resource-group }}
      acr-name: ${{ steps.outputs.outputs.acr-name }}
      acr-login-server: ${{ steps.outputs.outputs.acr-login-server }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Format
        id: fmt
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} init

      - name: Terraform Validate
        id: validate
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} validate

      - name: Terraform Plan
        id: plan
        run: |
          terraform -chdir=${{ env.TF_WORKING_DIR }} plan \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -input=false \
            -out=tfplan

      - name: Terraform Apply - Phase 1 (Resource Group)
        id: apply-phase1
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve -target=module.resource_group

      - name: Wait for Resource Group Propagation
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Waiting 15 seconds for resource group to be fully propagated..."
          sleep 15

      - name: Terraform Apply - Phase 2 (Network, Storage, ACR)
        id: apply-phase2
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve \
            -target=module.network \
            -target=module.storage \
            -target=module.acr

      - name: Wait for Network Resources
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: |
          echo "Waiting 30 seconds for network resources to be fully provisioned..."
          sleep 30

      - name: Terraform Apply - Phase 3 (AKS)
        id: apply-phase3
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        run: terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve -target=module.aks

      - name: Get Infrastructure Outputs
        id: outputs
        if: |
          (steps.apply-phase1.outcome == 'success' || steps.apply-phase1.outcome == 'skipped') &&
          (steps.apply-phase2.outcome == 'success' || steps.apply-phase2.outcome == 'skipped') && 
          (steps.apply-phase3.outcome == 'success' || steps.apply-phase3.outcome == 'skipped') &&
          (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          AKS_CLUSTER_NAME=$(terraform output -raw cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw resource_group_name)
          ACR_NAME=$(terraform output -raw acr_name)
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          
          echo "cluster-name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource-group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "acr-name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT

      - name: Create Infrastructure Summary
        if: steps.outputs.outcome == 'success'
        run: |
          echo "Infrastructure deployed at $(date)" > infrastructure-deployment.txt
          echo "AKS Cluster: ${{ steps.outputs.outputs.cluster-name }}" >> infrastructure-deployment.txt
          echo "Resource Group: ${{ steps.outputs.outputs.resource-group }}" >> infrastructure-deployment.txt
          echo "ACR: ${{ steps.outputs.outputs.acr-name }}" >> infrastructure-deployment.txt
          echo "ACR Login Server: ${{ steps.outputs.outputs.acr-login-server }}" >> infrastructure-deployment.txt

      - name: Upload Infrastructure Details
        if: steps.outputs.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-details
          path: infrastructure-deployment.txt
          retention-days: 30

  # ============================================================
  # STAGE 2: Docker Build and Push
  # ============================================================
  docker-build-push:
    name: 2 - Docker Build and Push
    runs-on: ubuntu-latest
    environment: dev
    needs: terraform-infrastructure
    if: needs.terraform-infrastructure.result == 'success'
    permissions:
      security-events: write
      actions: read
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug File Structure in Detail
        run: |
          echo "=== COMPREHENSIVE FILE STRUCTURE ANALYSIS ==="
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "Current directory: $(pwd)"
          ls -la apps/patient-service/
          cat apps/patient-service/Dockerfile || echo "Cannot read Dockerfile"

      - name: Login to Azure CLI with Service Principal
        run: |
          az login --service-principal \
            -u ${{ secrets.ARM_CLIENT_ID }} \
            -p ${{ secrets.ARM_CLIENT_SECRET }} \
            --tenant ${{ secrets.ARM_TENANT_ID }}
          az account set --subscription ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Get ACR Credentials
        id: acr-creds
        run: |
          ACR_NAME="${{ needs.terraform-infrastructure.outputs.acr-name }}"
          RESOURCE_GROUP="${{ needs.terraform-infrastructure.outputs.aks-resource-group }}"
          az acr update -n $ACR_NAME --resource-group $RESOURCE_GROUP --admin-enabled true
          ACR_USERNAME=$(az acr credential show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query "username" -o tsv)
          ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query "passwords[0].value" -o tsv)
          echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
          echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Log in to Azure Container Registry
        run: |
          echo "${{ steps.acr-creds.outputs.password }}" | docker login ${{ needs.terraform-infrastructure.outputs.acr-login-server }} \
            -u ${{ steps.acr-creds.outputs.username }} --password-stdin

      - name: Build and Push Patient Service
        run: |
          echo "Building Patient Service Docker image..."
          cd $GITHUB_WORKSPACE/apps/patient-service
          echo "Current directory: $(pwd)"
          ls -la
          cat Dockerfile || echo "Dockerfile missing!"
          docker build -f Dockerfile -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest .
          docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest
        
      - name: Build and Push Appointment Service
        run: |
          echo "Building Appointment Service Docker image..."
          cd $GITHUB_WORKSPACE/apps/appointment-service
          echo "Current directory: $(pwd)"
          ls -la
          cat Dockerfile || echo "Dockerfile missing!"
          docker build -f Dockerfile -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest .
          docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest

      - name: Create Build Summary
        run: |
          echo "Docker images built and pushed at $(date)" > docker-build-summary.txt
          echo "Patient Service: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest" >> docker-build-summary.txt
          echo "Appointment Service: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest" >> docker-build-summary.txt

      - name: Upload Build Summary
        uses: actions/upload-artifact@v4
        with:
          name: docker-build-summary
          path: docker-build-summary.txt
          retention-days: 30

  # ============================================================
  # STAGE 3: Deploy to AKS
  # ============================================================
  deploy-to-aks:
    name: 3 - Deploy to AKS
    runs-on: ubuntu-latest
    environment: dev
    needs:
      - terraform-infrastructure
      - docker-build-push
    if: |
      needs.terraform-infrastructure.result == 'success' && 
      needs.docker-build-push.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Build Summary
        uses: actions/download-artifact@v4
        with:
          name: docker-build-summary
          path: ./

      - name: Login to Azure CLI
        run: |
          az login --service-principal \
            -u ${{ secrets.ARM_CLIENT_ID }} \
            -p ${{ secrets.ARM_CLIENT_SECRET }} \
            --tenant ${{ secrets.ARM_TENANT_ID }}
          az account set --subscription ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform-infrastructure.outputs.aks-resource-group }} \
            --name ${{ needs.terraform-infrastructure.outputs.aks-cluster-name }} \
            --overwrite-existing

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 3.13.0

      - name: Clean Up Existing Namespace
        run: |
          echo "ðŸ” Checking for existing namespace: ${{ env.NAMESPACE }}"
          if kubectl get namespace ${{ env.NAMESPACE }} &>/dev/null; then
            echo "âš ï¸  Namespace exists. Deleting it..."
            kubectl delete namespace ${{ env.NAMESPACE }} --wait=true --timeout=300s
            echo "âœ… Namespace deleted successfully"
            sleep 10
          else
            echo "âœ… No existing namespace found"
          fi

      - name: Create Namespace
        run: |
          echo "ðŸ“¦ Creating namespace: ${{ env.NAMESPACE }}"
          kubectl create namespace ${{ env.NAMESPACE }}
          
          # Add labels to the namespace
          kubectl label namespace ${{ env.NAMESPACE }} \
            name=healthcare-dev \
            environment=dev \
            app=healthcare-microservices --overwrite
          
          echo "âœ… Namespace created and labeled successfully"
          kubectl get namespace ${{ env.NAMESPACE }} --show-labels

      - name: Build Helm dependencies
        run: |
          echo "Building Helm dependencies..."
          helm dependency build ./kubernetes/helm

      - name: Lint Helm Chart
        run: helm lint ./kubernetes/helm

      - name: Deploy Healthcare Microservices
        run: |
          echo "ðŸš€ Deploying healthcare microservices with Helm..."
          helm upgrade --install healthcare-microservices \
            ./kubernetes/helm \
            --namespace ${{ env.NAMESPACE }} \
            --set global.imageRegistry=${{ needs.terraform-infrastructure.outputs.acr-login-server }} \
            --set global.environment=${{ env.ENVIRONMENT }} \
            --set global.namespace=${{ env.NAMESPACE }} \
            --set patientService.image.repository=${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service \
            --set appointmentService.image.repository=${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service \
            --atomic \
            --wait --timeout 600s
          echo "âœ… Helm deployment completed successfully"

      - name: Verify Deployment
        run: |
          echo "=== Verifying Deployment ==="
          echo "1. Checking namespaces..."
          kubectl get namespaces
          echo "2. Checking deployments..."
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo "3. Checking pods..."
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "4. Checking services..."
          kubectl get services -n ${{ env.NAMESPACE }}
          echo "5. Checking ingress..."
          kubectl get ingress -n ${{ env.NAMESPACE }} || echo "No ingress found yet"
          echo "âœ… All Kubernetes resources verified"

      - name: Wait for Pods to be Ready
        run: |
          echo "â³ Waiting for all pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=patient-service -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=appointment-service -n ${{ env.NAMESPACE }} --timeout=300s
          echo "âœ… All pods are ready"

      - name: Create Deployment Summary
        run: |
          echo "=== Deployment Summary ===" > deployment-summary.txt
          echo "Deployment Time: $(date)" >> deployment-summary.txt
          echo "Cluster: ${{ needs.terraform-infrastructure.outputs.aks-cluster-name }}" >> deployment-summary.txt
          echo "Namespace: ${{ env.NAMESPACE }}" >> deployment-summary.txt
          echo "Status: SUCCESS" >> deployment-summary.txt
          echo "" >> deployment-summary.txt
          echo "Deployed Services:" >> deployment-summary.txt
          kubectl get deployments -n ${{ env.NAMESPACE }} >> deployment-summary.txt

      - name: Upload Deployment Summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.txt
          retention-days: 30

  # ============================================================
  # STAGE 4: Pipeline Summary
  # ============================================================
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs:
      - terraform-infrastructure
      - docker-build-push
      - deploy-to-aks
    if: always()
    steps:
      - name: Pipeline Status
        run: |
          echo "## Pipeline Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Infrastructure | ${{ needs.terraform-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Build & Push | ${{ needs.docker-build-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Deployment | ${{ needs.deploy-to-aks.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.terraform-infrastructure.result }}" == "success" && \
                "${{ needs.docker-build-push.result }}" == "success" && \
                "${{ needs.deploy-to-aks.result }}" == "success" ]]; then
            echo "ðŸŽ‰ **All stages completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "Your healthcare microservices are now deployed and running in AKS." >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Pipeline failed in one or more stages**" >> $GITHUB_STEP_SUMMARY
            echo "Check the failed stage logs for details." >> $GITHUB_STEP_SUMMARY
          fi