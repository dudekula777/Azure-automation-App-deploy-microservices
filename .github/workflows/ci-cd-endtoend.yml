name: End-to-End CI/CD Pipeline

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches: [ main ]

env:
  # Azure Service Principal Credentials
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  
  # Environment Configuration
  ENVIRONMENT: 'dev'
  NAMESPACE: 'healthcare-dev'
  TF_WORKING_DIR: 'infrastructure/environments/dev'

jobs:
  # STAGE 1: Terraform Infrastructure Provisioning
  terraform-infrastructure:
    name: '1 - Terraform Infrastructure'
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      aks-cluster-name: ${{ steps.outputs.outputs.cluster-name }}
      aks-resource-group: ${{ steps.outputs.outputs.resource-group }}
      acr-name: ${{ steps.outputs.outputs.acr-name }}
      acr-login-server: ${{ steps.outputs.outputs.acr-login-server }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.6.0'

    - name: Terraform Format
      id: fmt
      run: |
        terraform -chdir=${{ env.TF_WORKING_DIR }} fmt -check -recursive
      continue-on-error: true

    - name: Terraform Init
      id: init
      run: terraform -chdir=${{ env.TF_WORKING_DIR }} init

    - name: Terraform Validate
      id: validate
      run: terraform -chdir=${{ env.TF_WORKING_DIR }} validate

    - name: Terraform Plan
      id: plan
      run: |
        terraform -chdir=${{ env.TF_WORKING_DIR }} plan \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -input=false \
          -out=tfplan

    - name: Terraform Apply - Phase 1 (Resource Group)
      id: apply-phase1
      if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
      run: |
        terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve -target=module.resource_group

    - name: Wait for Resource Group Propagation
      if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
      run: |
        echo "Waiting 15 seconds for resource group to be fully propagated..."
        sleep 15

    - name: Terraform Apply - Phase 2 (Network, Storage, ACR)
      id: apply-phase2
      if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
      run: |
        terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve \
          -target=module.network \
          -target=module.storage \
          -target=module.acr

    - name: Wait for Network Resources
      if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
      run: |
        echo "Waiting 30 seconds for network resources to be fully provisioned..."
        sleep 30

    - name: Terraform Apply - Phase 3 (AKS)
      id: apply-phase3
      if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
      run: |
        terraform -chdir=${{ env.TF_WORKING_DIR }} apply -auto-approve -target=module.aks

    - name: Get Infrastructure Outputs
      id: outputs
      if: |
        (steps.apply-phase1.outcome == 'success' || steps.apply-phase1.outcome == 'skipped') &&
        (steps.apply-phase2.outcome == 'success' || steps.apply-phase2.outcome == 'skipped') && 
        (steps.apply-phase3.outcome == 'success' || steps.apply-phase3.outcome == 'skipped') &&
        (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
      run: |
        cd ${{ env.TF_WORKING_DIR }}
        
        # Get Terraform outputs
        AKS_CLUSTER_NAME=$(terraform output -raw cluster_name)
        AKS_RESOURCE_GROUP=$(terraform output -raw resource_group_name)
        ACR_NAME=$(terraform output -raw acr_name)
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        
        # Set outputs for next job
        echo "cluster-name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "resource-group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
        echo "acr-name=$ACR_NAME" >> $GITHUB_OUTPUT
        echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        
        echo "AKS Cluster: $AKS_CLUSTER_NAME"
        echo "Resource Group: $AKS_RESOURCE_GROUP"
        echo "ACR Name: $ACR_NAME"
        echo "ACR Login Server: $ACR_LOGIN_SERVER"

    - name: Create Infrastructure Summary
      if: steps.outputs.outcome == 'success'
      run: |
        echo "Infrastructure deployed at $(date)" > infrastructure-deployment.txt
        echo "AKS Cluster: ${{ steps.outputs.outputs.cluster-name }}" >> infrastructure-deployment.txt
        echo "Resource Group: ${{ steps.outputs.outputs.resource-group }}" >> infrastructure-deployment.txt
        echo "ACR: ${{ steps.outputs.outputs.acr-name }}" >> infrastructure-deployment.txt
        echo "ACR Login Server: ${{ steps.outputs.outputs.acr-login-server }}" >> infrastructure-deployment.txt

    - name: Upload Infrastructure Details
      if: steps.outputs.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: infrastructure-details
        path: infrastructure-deployment.txt
        retention-days: 30

  # STAGE 2: Docker Build and Push
  docker-build-push:
    name: '2 - Docker Build and Push'
    runs-on: ubuntu-latest
    environment: dev
    needs: terraform-infrastructure
    if: needs.terraform-infrastructure.result == 'success'
    
    permissions:
      security-events: write
      actions: read
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Comprehensive File Structure Analysis
      run: |
        echo "=== COMPREHENSIVE FILE STRUCTURE ANALYSIS ==="
        echo "Workspace: $GITHUB_WORKSPACE"
        echo "Current directory: $(pwd)"
        echo ""
        echo "=== ROOT DIRECTORY ==="
        ls -la
        echo ""
        echo "=== APPS DIRECTORY ==="
        ls -la apps/
        echo ""
        echo "=== PATIENT SERVICE DETAILED ==="
        ls -la apps/patient-service/ 2>/dev/null || echo "âŒ Patient service directory not found"
        echo "Patient Dockerfile exists: $(test -f apps/patient-service/Dockerfile && echo 'âœ… YES' || echo 'âŒ NO')"
        echo ""
        echo "=== APPOINTMENT SERVICE DETAILED ==="
        ls -la apps/appointment-service/ 2>/dev/null || echo "âŒ Appointment service directory not found"
        echo "Appointment Dockerfile exists: $(test -f apps/appointment-service/Dockerfile && echo 'âœ… YES' || echo 'âŒ NO')"
        echo ""
        echo "=== FIND ALL DOCKERFILES ==="
        find . -name "Dockerfile" -type f 2>/dev/null | head -10

    - name: Login to Azure CLI with Service Principal
      run: |
        az login --service-principal \
          -u ${{ secrets.ARM_CLIENT_ID }} \
          -p ${{ secrets.ARM_CLIENT_SECRET }} \
          --tenant ${{ secrets.ARM_TENANT_ID }}
        
        az account set --subscription ${{ secrets.ARM_SUBSCRIPTION_ID }}

    - name: Get ACR Credentials
      id: acr-creds
      run: |
        ACR_NAME="${{ needs.terraform-infrastructure.outputs.acr-name }}"
        RESOURCE_GROUP="${{ needs.terraform-infrastructure.outputs.aks-resource-group }}"
        
        echo "Getting ACR credentials for: $ACR_NAME in resource group: $RESOURCE_GROUP"
        
        # Enable admin user
        az acr update -n $ACR_NAME --resource-group $RESOURCE_GROUP --admin-enabled true
        
        # Get credentials
        ACR_USERNAME=$(az acr credential show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query "username" -o tsv)
        ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query "passwords[0].value" -o tsv)
        
        # Set outputs
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

    - name: Log in to Azure Container Registry
      run: |
        echo "${{ steps.acr-creds.outputs.password }}" | docker login ${{ needs.terraform-infrastructure.outputs.acr-login-server }} -u ${{ steps.acr-creds.outputs.username }} --password-stdin

    - name: Build and Push Services (Method 1 - Absolute Paths)
      id: build-method1
      run: |
        echo "=== METHOD 1: Using Absolute Paths ==="
        
        # Build Patient Service with absolute path
        echo "Building Patient Service..."
        docker build \
          -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest \
          -f $GITHUB_WORKSPACE/apps/patient-service/Dockerfile \
          $GITHUB_WORKSPACE/apps/patient-service/
        
        # Build Appointment Service with absolute path
        echo "Building Appointment Service..."
        docker build \
          -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest \
          -f $GITHUB_WORKSPACE/apps/appointment-service/Dockerfile \
          $GITHUB_WORKSPACE/apps/appointment-service/
        
        # Push both images
        echo "Pushing images to ACR..."
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest
        
        echo "âœ… Method 1 completed successfully"

    - name: Build and Push Services (Method 2 - Fallback)
      if: steps.build-method1.outcome == 'failure'
      id: build-method2
      run: |
        echo "=== METHOD 2: Fallback with Directory Change ==="
        
        # Build Patient Service
        echo "Building Patient Service..."
        cd $GITHUB_WORKSPACE/apps/patient-service
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        docker build -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest .
        
        # Build Appointment Service
        echo "Building Appointment Service..."
        cd $GITHUB_WORKSPACE/apps/appointment-service
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
        docker build -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest .
        
        # Push both images
        echo "Pushing images to ACR..."
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest
        
        echo "âœ… Method 2 completed successfully"

    - name: Create Emergency Dockerfiles (Last Resort)
      if: steps.build-method1.outcome == 'failure' && steps.build-method2.outcome == 'failure'
      id: build-method3
      run: |
        echo "=== METHOD 3: Creating Emergency Dockerfiles ==="
        
        # Create temporary directory
        mkdir -p /tmp/docker-build
        cd /tmp/docker-build
        
        # Create patient service files
        mkdir -p patient-service
        cat > patient-service/Dockerfile << 'EOF'
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install --only=production
COPY patient-service.js .
EXPOSE 3000
USER node
CMD ["node", "patient-service.js"]
EOF
        
        # Copy patient service files from repository
        cp $GITHUB_WORKSPACE/apps/patient-service/patient-service.js patient-service/
        cp $GITHUB_WORKSPACE/apps/patient-service/package.json patient-service/
        
        # Build patient service
        cd patient-service
        docker build -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest .
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest
        
        # Create appointment service files
        cd /tmp/docker-build
        mkdir -p appointment-service
        cat > appointment-service/Dockerfile << 'EOF'
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install --only=production
COPY appointment-service.js .
EXPOSE 3001
USER node
CMD ["node", "appointment-service.js"]
EOF
        
        # Copy appointment service files from repository
        cp $GITHUB_WORKSPACE/apps/appointment-service/appointment-service.js appointment-service/
        cp $GITHUB_WORKSPACE/apps/appointment-service/package.json appointment-service/
        
        # Build appointment service
        cd appointment-service
        docker build -t ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest .
        docker push ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest
        
        echo "âœ… Method 3 completed successfully"

    - name: Verify Images in ACR
      run: |
        echo "Verifying images were pushed to ACR..."
        az acr repository list --name ${{ needs.terraform-infrastructure.outputs.acr-name }} --output table

    - name: Run Trivy vulnerability scanner
      run: |
        echo "Running security scan on pushed images..."
        # Pull images first for scanning
        docker pull ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest
        docker pull ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest
        
        trivy image \
          --format sarif \
          --output trivy-results.sarif \
          ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest \
          ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Create Build Summary
      run: |
        echo "Docker images built and pushed at $(date)" > docker-build-summary.txt
        echo "Patient Service: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest" >> docker-build-summary.txt
        echo "Appointment Service: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest" >> docker-build-summary.txt
        echo "ACR Registry: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}" >> docker-build-summary.txt

    - name: Upload Build Summary
      uses: actions/upload-artifact@v4
      with:
        name: docker-build-summary
        path: docker-build-summary.txt
        retention-days: 30

    - name: Docker Build Complete
      run: |
        echo "âœ… Docker build and push completed successfully!"
        echo "Images available in ACR:"
        echo "- ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/patient-service:latest"
        echo "- ${{ needs.terraform-infrastructure.outputs.acr-login-server }}/appointment-service:latest"

  # STAGE 3: Deploy to AKS
  deploy-to-aks:
    name: '3 - Deploy to AKS'
    runs-on: ubuntu-latest
    environment: dev
    needs: 
      - terraform-infrastructure
      - docker-build-push
    if: |
      needs.terraform-infrastructure.result == 'success' && 
      needs.docker-build-push.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Build Summary
      uses: actions/download-artifact@v4
      with:
        name: docker-build-summary
        path: ./

    - name: Display Deployment Info
      run: |
        echo "=== Deployment Information ==="
        cat docker-build-summary.txt || echo "No build summary found"
        echo "Cluster: ${{ needs.terraform-infrastructure.outputs.aks-cluster-name }}"
        echo "Resource Group: ${{ needs.terraform-infrastructure.outputs.aks-resource-group }}"
        echo "ACR Registry: ${{ needs.terraform-infrastructure.outputs.acr-login-server }}"
        echo "Namespace: ${{ env.NAMESPACE }}"

    - name: Login to Azure CLI
      run: |
        az login --service-principal \
          -u ${{ secrets.ARM_CLIENT_ID }} \
          -p ${{ secrets.ARM_CLIENT_SECRET }} \
          --tenant ${{ secrets.ARM_TENANT_ID }}
        
        az account set --subscription ${{ secrets.ARM_SUBSCRIPTION_ID }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.terraform-infrastructure.outputs.aks-resource-group }} \
          --name ${{ needs.terraform-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Verify cluster connection
      run: |
        echo "Testing cluster connection..."
        kubectl cluster-info
        kubectl get nodes
        echo "âœ… Cluster connection successful"

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.13.0'

    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        echo "âœ… Namespace created/verified: ${{ env.NAMESPACE }}"

    - name: Deploy NGINX Ingress Controller
      run: |
        echo "Deploying NGINX Ingress Controller..."
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        
        # Check if ingress-nginx already exists
        if helm list -n ingress-nginx | grep -q ingress-nginx; then
          echo "Ingress controller already exists, upgrading..."
          helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --set controller.service.type=LoadBalancer \
            --set controller.service.externalTrafficPolicy=Local \
            --wait
        else
          echo "Installing new ingress controller..."
          helm install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.service.type=LoadBalancer \
            --set controller.service.externalTrafficPolicy=Local \
            --wait
        fi

    - name: Wait for ingress controller
      run: |
        echo "Waiting for ingress controller to be ready..."
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=300s
        echo "âœ… Ingress controller is ready"

    - name: Deploy Healthcare Microservices
      run: |
        echo "Deploying healthcare microservices with Helm..."
        helm upgrade --install healthcare-microservices \
          ./kubernetes/helm \
          --namespace ${{ env.NAMESPACE }} \
          --create-namespace \
          --set global.imageRegistry=${{ needs.terraform-infrastructure.outputs.acr-login-server }} \
          --set global.environment=${{ env.ENVIRONMENT }} \
          --set global.namespace=${{ env.NAMESPACE }} \
          --set patientService.image.tag=latest \
          --set appointmentService.image.tag=latest \
          --wait --timeout 600s
        echo "âœ… Helm deployment completed"

    - name: Verify deployment
      run: |
        echo "=== Verifying Deployment ==="
        
        echo "1. Checking deployments..."
        kubectl get deployments -n ${{ env.NAMESPACE }}
        
        echo "2. Checking pods..."
        kubectl get pods -n ${{ env.NAMESPACE }} -o wide
        
        echo "3. Checking services..."
        kubectl get services -n ${{ env.NAMESPACE }}
        
        echo "4. Checking ingress..."
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        echo "âœ… All Kubernetes resources verified"

    - name: Wait for pods to be ready
      run: |
        echo "Waiting for all pods to be ready..."
        kubectl wait --for=condition=ready pod -l app=patient-service -n ${{ env.NAMESPACE }} --timeout=300s
        kubectl wait --for=condition=ready pod -l app=appointment-service -n ${{ env.NAMESPACE }} --timeout=300s
        echo "âœ… All pods are ready"

    - name: Run health checks
      id: healthchecks
      run: |
        echo "Running health checks..."
        
        # Get ingress external IP
        echo "Getting ingress external IP..."
        EXTERNAL_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "âš ï¸  No external IP found yet, waiting..."
          sleep 30
          EXTERNAL_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        fi
        
        if [ -n "$EXTERNAL_IP" ]; then
          echo "External IP: $EXTERNAL_IP"
          echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_ENV
          
          # Wait a bit more for services to be fully ready
          sleep 20
          
          # Patient service health check
          echo "Testing Patient Service..."
          PATIENT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$EXTERNAL_IP/patients/health || echo "curl_failed")
          echo "Patient Service HTTP Status: $PATIENT_STATUS"
          
          # Appointment service health check
          echo "Testing Appointment Service..."
          APPOINTMENT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$EXTERNAL_IP/appointments/health || echo "curl_failed")
          echo "Appointment Service HTTP Status: $APPOINTMENT_STATUS"
          
          if [ "$PATIENT_STATUS" = "200" ] && [ "$APPOINTMENT_STATUS" = "200" ]; then
            echo "âœ… All health checks passed!"
            echo "HEALTH_CHECKS_PASSED=true" >> $GITHUB_ENV
          else
            echo "âŒ Health checks failed"
            echo "HEALTH_CHECKS_PASSED=false" >> $GITHUB_ENV
            exit 1
          fi
        else
          echo "âŒ Could not retrieve external IP for ingress"
          echo "HEALTH_CHECKS_PASSED=false" >> $GITHUB_ENV
          exit 1
        fi

    - name: Create deployment summary
      if: always()
      run: |
        echo "=== Deployment Summary ===" > deployment-summary.txt
        echo "Deployment Time: $(date)" >> deployment-summary.txt
        echo "Cluster: ${{ needs.terraform-infrastructure.outputs.aks-cluster-name }}" >> deployment-summary.txt
        echo "Namespace: ${{ env.NAMESPACE }}" >> deployment-summary.txt
        echo "External IP: ${{ env.EXTERNAL_IP }}" >> deployment-summary.txt
        echo "Health Checks: ${{ env.HEALTH_CHECKS_PASSED || 'unknown' }}" >> deployment-summary.txt
        echo "" >> deployment-summary.txt
        echo "Application URLs:" >> deployment-summary.txt
        echo "- Patient Service: http://${{ env.EXTERNAL_IP }}/patients" >> deployment-summary.txt
        echo "- Appointment Service: http://${{ env.EXTERNAL_IP }}/appointments" >> deployment-summary.txt
        echo "- Patient Health: http://${{ env.EXTERNAL_IP }}/patients/health" >> deployment-summary.txt
        echo "- Appointment Health: http://${{ env.EXTERNAL_IP }}/appointments/health" >> deployment-summary.txt
        
        cat deployment-summary.txt

    - name: Upload deployment summary
      uses: actions/upload-artifact@v4
      with:
        name: deployment-summary
        path: deployment-summary.txt
        retention-days: 30

    - name: Deployment Success
      if: success()
      run: |
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸ“± Your application is now live!"
        echo ""
        echo "Access your services at:"
        echo "Patient Service: http://${{ env.EXTERNAL_IP }}/patients"
        echo "Appointment Service: http://${{ env.EXTERNAL_IP }}/appointments"
        echo ""
        echo "Health checks:"
        echo "Patient Health: http://${{ env.EXTERNAL_IP }}/patients/health"
        echo "Appointment Health: http://${{ env.EXTERNAL_IP }}/appointments/health"

  # Final Summary
  pipeline-summary:
    name: 'Pipeline Summary'
    runs-on: ubuntu-latest
    needs: 
      - terraform-infrastructure
      - docker-build-push
      - deploy-to-aks
    if: always()

    steps:
    - name: Pipeline Status
      run: |
        echo "## Pipeline Execution Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Terraform Infrastructure | ${{ needs.terraform-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Build & Push | ${{ needs.docker-build-push.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| AKS Deployment | ${{ needs.deploy-to-aks.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.terraform-infrastructure.result }}" == "success" && "${{ needs.docker-build-push.result }}" == "success" && "${{ needs.deploy-to-aks.result }}" == "success" ]]; then
          echo "ðŸŽ‰ **All stages completed successfully!**" >> $GITHUB_STEP_SUMMARY
          echo "Your application is now deployed and running in AKS." >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Pipeline failed in one or more stages**" >> $GITHUB_STEP_SUMMARY
          echo "Check the failed stage logs for details." >> $GITHUB_STEP_SUMMARY
        fi